## 1.构造函数
只进行没有实际意义的初始化，有意义的初始化放在Init()方法中。
优点：排版方便，无担心有无初始化
缺点：①不易报告错误，不能使用异常
         ②构造函数内调用虚函数，调用不会派发到子类实现中
有意义的初始化可以使用Init()方法。

## 2.默认构造函数

## 3.明确构造函数 
单参构造函数应使用explicit 关键字，避免不合时宜的类型转换。

## 4.拷贝构造函数
一般不需要拷贝构造函数 或 赋值操作，单编译器会自动生成，且public。
应添加为私有的空函数。
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
TypeName(const TypeName&); \
void operator=(const TypeName&)
***当类作为容器值，应使用指针--智能指针

## 5.结构体和类 
只有数据时struct  其他class

## 6.继承
使用组合比继承更合适，只能用公有继承。
实现继承：继承实现代码
接口继承：仅继承方法名称
优点：减少代码量
缺点：理解困难，变得复杂
***如想要私有继承 --> 采用包含基类实例作为成员的方式代替
is-a 使用继承   has-a 使用组合
基类析构函数要为虚函数
提高可读性----当重定义派生的虚函数时，在派生类中明确声明其为virtual。根本原因：如果遗漏virtual，阅读者需要检索类的所有祖先以确定该函数是否为虚函数


## 7.多重继承
只有当所有超类除第一个外都是纯接口时才能使用多重继承，这些类以Interface后缀。

## 8.接口
Interface为后缀。（非必须）
满足以下要求时为纯接口：
a.只有纯虚函数（=0）和静态函数
b.没有非静态数据成员
c.没有定义 构造函数   如果有 没有参数 且protected
d.如果是子类也只能继承满足上述条件并以Interface为后缀的类
优点：以Interface 为后缀可令他人知道不能为该接口类增加实现函数或非静态数据成员，
这一点对于多重继承尤其重要。

## 9.操作符重载
除少数特定环境，不重载操作符。
缺点：
a.误以为耗时的操作像操作符一样轻巧
b.查找重载操作符的调用处更方便
c.指针操作时容易出错
d.意想不到的错误，重载&的类不能前置声明

避免重载，可用函数代替。

## 10.存取控制
将数据成员私有化，并提供相关存取函数，如定义变量foo_及取值函数foo()、赋值函数
set_foo()。
存取函数的定义一般内联在头文件中。

## 11.声明次序
每一块中，声明次序一般如下：
1) typedefs 和enums；
2) 常量；
3) 构造函数；
4) 析构函数；
5) 成员函数，含静态成员函数；
6) 数据成员，含静态数据成员。

## 12.编写短小的函数
如果函数超过40 行，可以考虑在不影响程序结构的情况下将其分割一下。


--------------------------------------------------------------------------------------------
小结：
1. 不在构造函数中做太多逻辑相关的初始化；
2. 编译器提供的默认构造函数不会对变量进行初始化，如果定义了其他构造函数，编译器
不再提供，需要编码者自行提供默认构造函数；
3. 为避免隐式转换，需将单参数构造函数声明为explicit；
4. 为避免拷贝构造函数、赋值操作的滥用和编译器自动生成，可目前声明其为private
且无需实现；
5. 仅在作为数据集合时使用struct；
6. 组合>实现继承>接口继承>私有继承，子类重载的虚函数也要声明virtual关键字，
虽然编译器允许不这样做；
7. 避免使用多重继承，使用时，除一个基类含有实现外，其他基类均为纯接口；
8. 接口类类名以Interface为后缀，除提供带实现的虚析构函数、静态成员函数外，其
他均为纯虚函数，不定义非静态数据成员，不提供构造函数，提供的话，声明为protected；
9. 为降低复杂性，尽量不重载操作符，模板、标准类中使用时提供文档说明；
10. 存取函数一般内联在头文件中；
11. 声明次序：public->protected->private；
12. 函数体尽量短小、紧凑，功能单一。


